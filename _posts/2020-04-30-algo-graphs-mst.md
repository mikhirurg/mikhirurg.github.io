---
layout: post
title:  "Остовное дерево"
date:   2020-04-30 14:30:00 +0300
categories: algo graphs
permalink: /:categories/:day/:year/:month/:title.html
---

## Задача:
Даны точки на плоскости - вершины полного графа. Вес ребра равен расстоянию между точками, соответствующими концам этого ребра. 
Требуется найти минимальное остовное дерево в данном графе. 

## Решение:
<details>
В данной задаче предлагается реализовать модификацию алгоритма Прима.


{% highlight java %}
public static double getDist(Point a, Point b) {
        return Math.sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));
    }
 
boolean[] used = new boolean[n];
double[] minEdge = new double[n];
int[] minEdgeEnd = new int[n];
Arrays.fill(used, false);
Arrays.fill(minEdge, INF);
Arrays.fill(minEdgeEnd, -1);
minEdge[0] = 0;
 
double sum = 0;
 
for (int i = 0; i < n; i++) {
     int v = -1;
     for (int j = 0; j < n; j++) {
         if (!used[j]) {
            if (v == -1 || minEdge[j] < minEdge[v]) {
                v = j;
            }
      }
 }
 used[v] = true;
 if (minEdgeEnd[v] != -1) {
    sum += getDist(points.get(v), points.get(minEdgeEnd[v]));
 }
 for (int u = 0; u < n; u++) {
     double tmp = getDist(points.get(v), points.get(u));
     if (tmp < minEdge[u]) {
        minEdge[u] = tmp;
        minEdgeEnd[u] = v;
     }
  }
 }
{% endhighlight %}

Для каждой вершины графа храним минимальное ребро, которое ведёт в вершину, которую уже выбрали в остовное дерево.
<br />
Соответственно при обработке не выбранных вершин графа необходимо сначала перебрать все минимальные ребра, чтобы выбрать очередную вершину, которая будет добавлена в остов.
<br />
При добавлении ребра в остов необходимо пересчитать минимальные ребра ведущие в остов, для вершин еще не включенных в остовное дерево.
<br />
Это решение оптимально для плотных графов, так как выбирать минимальное ребро мы можем за O(n), и пересчитывать длины минимальных ребер для не выбранных вершин мы тоже умеем за O(n). В случае же разреженных графов где для поиска минимального ребра используется двоичная куча, мы будем выбирать минимум за O(log n), но обновлять минимальные вершины будем дольше, так как добавление элемента занимает O(log n). В итоге обновление вершин занимает O(n log n). Если запустить такой алгоритм на полных графах, его асимптотика будет O(n^2 log n), что не очень быстро.
<br />
Также для экономии памяти можно не хранить матрицу весов, а каждый раз вычислять расстояние между вершинами.


</details>

### Похожие задачи в тестирующих системах

#### informatics.mccme.ru

[Связное множество](https://informatics.mccme.ru/mod/statements/view3.php?id=26153&chapterid=605#1)

